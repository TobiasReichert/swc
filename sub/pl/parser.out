Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> file
Rule 1     file -> functions
Rule 2     file -> body
Rule 3     functions -> function
Rule 4     functions -> functions function
Rule 5     funcall -> ID LPAREN funcall_params RPAREN
Rule 6     funcall_params -> empty
Rule 7     funcall_params -> expression
Rule 8     funcall_params -> funcall_params COMMA expression
Rule 9     function -> DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE
Rule 10    fun_params -> empty
Rule 11    fun_params -> ID
Rule 12    fun_params -> fun_pointer
Rule 13    fun_params -> fun_params COMMA fun_pointer
Rule 14    fun_params -> fun_params COMMA ID
Rule 15    fun_pointer -> ID LPAREN RPAREN
Rule 16    body -> ex
Rule 17    body -> body ex
Rule 18    ex -> assign SEMI
Rule 19    ex -> return SEMI
Rule 20    ex -> write SEMI
Rule 21    ex -> readd SEMI
Rule 22    ex -> funcall SEMI
Rule 23    ex -> readd_esc SEMI
Rule 24    ex -> nop SEMI
Rule 25    ex -> if
Rule 26    ex -> foreach
Rule 27    ex -> readd_esc
Rule 28    nop -> NOP
Rule 29    if -> IF LPAREN expression RPAREN LBRACE body RBRACE
Rule 30    if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
Rule 31    if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
Rule 32    foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
Rule 33    return -> RETURN expression
Rule 34    write -> WRITE expression
Rule 35    readd -> READD expression
Rule 36    readd_esc -> LT string GT
Rule 37    readd_esc -> LT ID string GT
Rule 38    assign -> var EQUALS expression
Rule 39    expression -> value
Rule 40    expression -> bool_ex
Rule 41    expression -> op_ex
Rule 42    bool_ex -> bool_value EQ bool_value
Rule 43    bool_ex -> bool_value NE bool_value
Rule 44    bool_ex -> bool_value LE bool_value
Rule 45    bool_ex -> bool_value GE bool_value
Rule 46    bool_ex -> bool_value LT bool_value
Rule 47    bool_ex -> bool_value GT bool_value
Rule 48    bool_ex -> bool_value LOR bool_value
Rule 49    bool_ex -> bool_value LAND bool_value
Rule 50    bool_ex -> LNOT bool_value
Rule 51    bool_ex -> LPAREN bool_ex RPAREN
Rule 52    bool_value -> value
Rule 53    bool_value -> op_ex
Rule 54    op_ex -> value PLUS value
Rule 55    op_ex -> value MINUS value
Rule 56    op_ex -> value TIMES value
Rule 57    op_ex -> value DIVIDE value
Rule 58    op_ex -> value MOD value
Rule 59    op_ex -> value LSHIFT value
Rule 60    op_ex -> value RSHIFT value
Rule 61    op_ex -> value OR value
Rule 62    op_ex -> value AND value
Rule 63    op_ex -> value XOR value
Rule 64    op_ex -> value PLUS op_ex
Rule 65    op_ex -> value MINUS op_ex
Rule 66    op_ex -> value TIMES op_ex
Rule 67    op_ex -> value DIVIDE op_ex
Rule 68    op_ex -> value MOD op_ex
Rule 69    op_ex -> value LSHIFT op_ex
Rule 70    op_ex -> value RSHIFT op_ex
Rule 71    op_ex -> value OR op_ex
Rule 72    op_ex -> value AND op_ex
Rule 73    op_ex -> value XOR op_ex
Rule 74    op_ex -> LPAREN op_ex RPAREN
Rule 75    value -> var
Rule 76    value -> int
Rule 77    value -> float
Rule 78    value -> string
Rule 79    value -> bool
Rule 80    value -> funcall
Rule 81    value -> list
Rule 82    value -> array_get
Rule 83    value -> tree_get
Rule 84    int -> INT
Rule 85    float -> FLOAT
Rule 86    string -> STRING
Rule 87    string -> MULTI_STRING
Rule 88    bool -> TRUE
Rule 89    bool -> FALSE
Rule 90    list -> LBRACKET array RBRACKET
Rule 91    array -> value
Rule 92    array -> array COMMA value
Rule 93    array_get -> ID LBRACKET INT RBRACKET
Rule 94    tree_get -> ID LBRACKET string RBRACKET
Rule 95    var -> ID
Rule 96    empty -> <empty>

Terminals, with rules where they appear

AND                  : 62 72
COLON                : 32
COMMA                : 8 13 14 92
DEF                  : 9
DIVIDE               : 57 67
ELSE                 : 30 31
EQ                   : 42
EQUALS               : 38
FALSE                : 89
FLOAT                : 85
FOR                  : 32
GE                   : 45
GT                   : 36 37 47
ID                   : 5 9 11 14 15 37 93 94 95
IF                   : 29 30 31
INT                  : 84 93
LAND                 : 49
LBRACE               : 9 29 30 31 31 32
LBRACKET             : 90 93 94
LE                   : 44
LNOT                 : 50
LOR                  : 48
LPAREN               : 5 9 15 29 30 31 32 51 74
LSHIFT               : 59 69
LT                   : 36 37 46
MINUS                : 55 65
MOD                  : 58 68
MULTI_STRING         : 87
NE                   : 43
NOP                  : 28
OR                   : 61 71
PLUS                 : 54 64
RBRACE               : 9 29 30 31 31 32
RBRACKET             : 90 93 94
READD                : 35
RETURN               : 33
RPAREN               : 5 9 15 29 30 31 32 51 74
RSHIFT               : 60 70
SEMI                 : 18 19 20 21 22 23 24
STRING               : 86
TIMES                : 56 66
TRUE                 : 88
WRITE                : 34
XOR                  : 63 73
error                : 

Nonterminals, with rules where they appear

array                : 90 92
array_get            : 82
assign               : 18
body                 : 2 9 17 29 30 31 31 32
bool                 : 79
bool_ex              : 40 51
bool_value           : 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50
empty                : 6 10
ex                   : 16 17
expression           : 7 8 29 30 31 33 34 35 38
file                 : 0
float                : 77
foreach              : 26
fun_params           : 9 13 14
fun_pointer          : 12 13
funcall              : 22 80
funcall_params       : 5 8
function             : 3 4
functions            : 1 4
if                   : 25 30
int                  : 76
list                 : 81
nop                  : 24
op_ex                : 41 53 64 65 66 67 68 69 70 71 72 73 74
readd                : 21
readd_esc            : 23 27
return               : 19
string               : 36 37 78 94
tree_get             : 83
value                : 32 39 52 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 65 66 67 68 69 70 71 72 73 91 92
var                  : 32 38 75
write                : 20

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . functions
    (2) file -> . body
    (3) functions -> . function
    (4) functions -> . functions function
    (16) body -> . ex
    (17) body -> . body ex
    (9) function -> . DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    DEF             shift and go to state 7
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    body                           shift and go to state 15
    function                       shift and go to state 1
    functions                      shift and go to state 9
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    funcall                        shift and go to state 4
    write                          shift and go to state 11
    ex                             shift and go to state 5
    file                           shift and go to state 6
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 1

    (3) functions -> function .

    DEF             reduce using rule 3 (functions -> function .)
    $end            reduce using rule 3 (functions -> function .)


state 2

    (33) return -> RETURN . expression
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 48
    tree_get                       shift and go to state 29

state 3

    (21) ex -> readd . SEMI

    SEMI            shift and go to state 49


state 4

    (22) ex -> funcall . SEMI

    SEMI            shift and go to state 50


state 5

    (16) body -> ex .

    RETURN          reduce using rule 16 (body -> ex .)
    WRITE           reduce using rule 16 (body -> ex .)
    READD           reduce using rule 16 (body -> ex .)
    ID              reduce using rule 16 (body -> ex .)
    LT              reduce using rule 16 (body -> ex .)
    NOP             reduce using rule 16 (body -> ex .)
    IF              reduce using rule 16 (body -> ex .)
    FOR             reduce using rule 16 (body -> ex .)
    $end            reduce using rule 16 (body -> ex .)
    RBRACE          reduce using rule 16 (body -> ex .)


state 6

    (0) S' -> file .



state 7

    (9) function -> DEF . ID LPAREN fun_params RPAREN LBRACE body RBRACE

    ID              shift and go to state 51


state 8

    (25) ex -> if .

    RBRACE          reduce using rule 25 (ex -> if .)
    RETURN          reduce using rule 25 (ex -> if .)
    WRITE           reduce using rule 25 (ex -> if .)
    READD           reduce using rule 25 (ex -> if .)
    ID              reduce using rule 25 (ex -> if .)
    LT              reduce using rule 25 (ex -> if .)
    NOP             reduce using rule 25 (ex -> if .)
    IF              reduce using rule 25 (ex -> if .)
    FOR             reduce using rule 25 (ex -> if .)
    $end            reduce using rule 25 (ex -> if .)


state 9

    (1) file -> functions .
    (4) functions -> functions . function
    (9) function -> . DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE

    $end            reduce using rule 1 (file -> functions .)
    DEF             shift and go to state 7

    function                       shift and go to state 52

state 10

    (36) readd_esc -> LT . string GT
    (37) readd_esc -> LT . ID string GT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING

    ID              shift and go to state 53
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31

    string                         shift and go to state 54

state 11

    (20) ex -> write . SEMI

    SEMI            shift and go to state 55


state 12

    (26) ex -> foreach .

    RBRACE          reduce using rule 26 (ex -> foreach .)
    RETURN          reduce using rule 26 (ex -> foreach .)
    WRITE           reduce using rule 26 (ex -> foreach .)
    READD           reduce using rule 26 (ex -> foreach .)
    ID              reduce using rule 26 (ex -> foreach .)
    LT              reduce using rule 26 (ex -> foreach .)
    NOP             reduce using rule 26 (ex -> foreach .)
    IF              reduce using rule 26 (ex -> foreach .)
    FOR             reduce using rule 26 (ex -> foreach .)
    $end            reduce using rule 26 (ex -> foreach .)


state 13

    (38) assign -> var . EQUALS expression

    EQUALS          shift and go to state 56


state 14

    (23) ex -> readd_esc . SEMI
    (27) ex -> readd_esc .

    SEMI            shift and go to state 57
    RBRACE          reduce using rule 27 (ex -> readd_esc .)
    RETURN          reduce using rule 27 (ex -> readd_esc .)
    WRITE           reduce using rule 27 (ex -> readd_esc .)
    READD           reduce using rule 27 (ex -> readd_esc .)
    ID              reduce using rule 27 (ex -> readd_esc .)
    LT              reduce using rule 27 (ex -> readd_esc .)
    NOP             reduce using rule 27 (ex -> readd_esc .)
    IF              reduce using rule 27 (ex -> readd_esc .)
    FOR             reduce using rule 27 (ex -> readd_esc .)
    $end            reduce using rule 27 (ex -> readd_esc .)


state 15

    (2) file -> body .
    (17) body -> body . ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    $end            reduce using rule 2 (file -> body .)
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 58
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 16

    (19) ex -> return . SEMI

    SEMI            shift and go to state 59


state 17

    (32) foreach -> FOR . LPAREN var COLON value RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 60


state 18

    (34) write -> WRITE . expression
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 61
    tree_get                       shift and go to state 29

state 19

    (24) ex -> nop . SEMI

    SEMI            shift and go to state 62


state 20

    (5) funcall -> ID . LPAREN funcall_params RPAREN
    (95) var -> ID .

    LPAREN          shift and go to state 63
    EQUALS          reduce using rule 95 (var -> ID .)


state 21

    (29) if -> IF . LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> IF . LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> IF . LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE

    LPAREN          shift and go to state 64


state 22

    (35) readd -> READD . expression
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 65
    tree_get                       shift and go to state 29

state 23

    (28) nop -> NOP .

    SEMI            reduce using rule 28 (nop -> NOP .)


state 24

    (18) ex -> assign . SEMI

    SEMI            shift and go to state 66


state 25

    (50) bool_ex -> LNOT . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 68
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 26

    (76) value -> int .

    RPAREN          reduce using rule 76 (value -> int .)
    PLUS            reduce using rule 76 (value -> int .)
    MINUS           reduce using rule 76 (value -> int .)
    TIMES           reduce using rule 76 (value -> int .)
    DIVIDE          reduce using rule 76 (value -> int .)
    MOD             reduce using rule 76 (value -> int .)
    LSHIFT          reduce using rule 76 (value -> int .)
    RSHIFT          reduce using rule 76 (value -> int .)
    OR              reduce using rule 76 (value -> int .)
    AND             reduce using rule 76 (value -> int .)
    XOR             reduce using rule 76 (value -> int .)
    SEMI            reduce using rule 76 (value -> int .)
    EQ              reduce using rule 76 (value -> int .)
    NE              reduce using rule 76 (value -> int .)
    LE              reduce using rule 76 (value -> int .)
    GE              reduce using rule 76 (value -> int .)
    LT              reduce using rule 76 (value -> int .)
    GT              reduce using rule 76 (value -> int .)
    LOR             reduce using rule 76 (value -> int .)
    LAND            reduce using rule 76 (value -> int .)
    COMMA           reduce using rule 76 (value -> int .)
    RBRACKET        reduce using rule 76 (value -> int .)


state 27

    (77) value -> float .

    RPAREN          reduce using rule 77 (value -> float .)
    PLUS            reduce using rule 77 (value -> float .)
    MINUS           reduce using rule 77 (value -> float .)
    TIMES           reduce using rule 77 (value -> float .)
    DIVIDE          reduce using rule 77 (value -> float .)
    MOD             reduce using rule 77 (value -> float .)
    LSHIFT          reduce using rule 77 (value -> float .)
    RSHIFT          reduce using rule 77 (value -> float .)
    OR              reduce using rule 77 (value -> float .)
    AND             reduce using rule 77 (value -> float .)
    XOR             reduce using rule 77 (value -> float .)
    SEMI            reduce using rule 77 (value -> float .)
    EQ              reduce using rule 77 (value -> float .)
    NE              reduce using rule 77 (value -> float .)
    LE              reduce using rule 77 (value -> float .)
    GE              reduce using rule 77 (value -> float .)
    LT              reduce using rule 77 (value -> float .)
    GT              reduce using rule 77 (value -> float .)
    LOR             reduce using rule 77 (value -> float .)
    LAND            reduce using rule 77 (value -> float .)
    COMMA           reduce using rule 77 (value -> float .)
    RBRACKET        reduce using rule 77 (value -> float .)


state 28

    (88) bool -> TRUE .

    PLUS            reduce using rule 88 (bool -> TRUE .)
    MINUS           reduce using rule 88 (bool -> TRUE .)
    TIMES           reduce using rule 88 (bool -> TRUE .)
    DIVIDE          reduce using rule 88 (bool -> TRUE .)
    MOD             reduce using rule 88 (bool -> TRUE .)
    LSHIFT          reduce using rule 88 (bool -> TRUE .)
    RSHIFT          reduce using rule 88 (bool -> TRUE .)
    OR              reduce using rule 88 (bool -> TRUE .)
    AND             reduce using rule 88 (bool -> TRUE .)
    XOR             reduce using rule 88 (bool -> TRUE .)
    SEMI            reduce using rule 88 (bool -> TRUE .)
    RPAREN          reduce using rule 88 (bool -> TRUE .)
    COMMA           reduce using rule 88 (bool -> TRUE .)
    EQ              reduce using rule 88 (bool -> TRUE .)
    NE              reduce using rule 88 (bool -> TRUE .)
    LE              reduce using rule 88 (bool -> TRUE .)
    GE              reduce using rule 88 (bool -> TRUE .)
    LT              reduce using rule 88 (bool -> TRUE .)
    GT              reduce using rule 88 (bool -> TRUE .)
    LOR             reduce using rule 88 (bool -> TRUE .)
    LAND            reduce using rule 88 (bool -> TRUE .)
    RBRACKET        reduce using rule 88 (bool -> TRUE .)


state 29

    (83) value -> tree_get .

    RPAREN          reduce using rule 83 (value -> tree_get .)
    PLUS            reduce using rule 83 (value -> tree_get .)
    MINUS           reduce using rule 83 (value -> tree_get .)
    TIMES           reduce using rule 83 (value -> tree_get .)
    DIVIDE          reduce using rule 83 (value -> tree_get .)
    MOD             reduce using rule 83 (value -> tree_get .)
    LSHIFT          reduce using rule 83 (value -> tree_get .)
    RSHIFT          reduce using rule 83 (value -> tree_get .)
    OR              reduce using rule 83 (value -> tree_get .)
    AND             reduce using rule 83 (value -> tree_get .)
    XOR             reduce using rule 83 (value -> tree_get .)
    SEMI            reduce using rule 83 (value -> tree_get .)
    EQ              reduce using rule 83 (value -> tree_get .)
    NE              reduce using rule 83 (value -> tree_get .)
    LE              reduce using rule 83 (value -> tree_get .)
    GE              reduce using rule 83 (value -> tree_get .)
    LT              reduce using rule 83 (value -> tree_get .)
    GT              reduce using rule 83 (value -> tree_get .)
    LOR             reduce using rule 83 (value -> tree_get .)
    LAND            reduce using rule 83 (value -> tree_get .)
    COMMA           reduce using rule 83 (value -> tree_get .)
    RBRACKET        reduce using rule 83 (value -> tree_get .)


state 30

    (40) expression -> bool_ex .

    SEMI            reduce using rule 40 (expression -> bool_ex .)
    RPAREN          reduce using rule 40 (expression -> bool_ex .)
    COMMA           reduce using rule 40 (expression -> bool_ex .)


state 31

    (87) string -> MULTI_STRING .

    PLUS            reduce using rule 87 (string -> MULTI_STRING .)
    MINUS           reduce using rule 87 (string -> MULTI_STRING .)
    TIMES           reduce using rule 87 (string -> MULTI_STRING .)
    DIVIDE          reduce using rule 87 (string -> MULTI_STRING .)
    MOD             reduce using rule 87 (string -> MULTI_STRING .)
    LSHIFT          reduce using rule 87 (string -> MULTI_STRING .)
    RSHIFT          reduce using rule 87 (string -> MULTI_STRING .)
    OR              reduce using rule 87 (string -> MULTI_STRING .)
    AND             reduce using rule 87 (string -> MULTI_STRING .)
    XOR             reduce using rule 87 (string -> MULTI_STRING .)
    SEMI            reduce using rule 87 (string -> MULTI_STRING .)
    EQ              reduce using rule 87 (string -> MULTI_STRING .)
    NE              reduce using rule 87 (string -> MULTI_STRING .)
    LE              reduce using rule 87 (string -> MULTI_STRING .)
    GE              reduce using rule 87 (string -> MULTI_STRING .)
    LT              reduce using rule 87 (string -> MULTI_STRING .)
    GT              reduce using rule 87 (string -> MULTI_STRING .)
    LOR             reduce using rule 87 (string -> MULTI_STRING .)
    LAND            reduce using rule 87 (string -> MULTI_STRING .)
    RPAREN          reduce using rule 87 (string -> MULTI_STRING .)
    COMMA           reduce using rule 87 (string -> MULTI_STRING .)
    RBRACKET        reduce using rule 87 (string -> MULTI_STRING .)


state 32

    (41) expression -> op_ex .
    (53) bool_value -> op_ex .

    SEMI            reduce using rule 41 (expression -> op_ex .)
    RPAREN          reduce using rule 41 (expression -> op_ex .)
    COMMA           reduce using rule 41 (expression -> op_ex .)
    EQ              reduce using rule 53 (bool_value -> op_ex .)
    NE              reduce using rule 53 (bool_value -> op_ex .)
    LE              reduce using rule 53 (bool_value -> op_ex .)
    GE              reduce using rule 53 (bool_value -> op_ex .)
    LT              reduce using rule 53 (bool_value -> op_ex .)
    GT              reduce using rule 53 (bool_value -> op_ex .)
    LOR             reduce using rule 53 (bool_value -> op_ex .)
    LAND            reduce using rule 53 (bool_value -> op_ex .)


state 33

    (42) bool_ex -> bool_value . EQ bool_value
    (43) bool_ex -> bool_value . NE bool_value
    (44) bool_ex -> bool_value . LE bool_value
    (45) bool_ex -> bool_value . GE bool_value
    (46) bool_ex -> bool_value . LT bool_value
    (47) bool_ex -> bool_value . GT bool_value
    (48) bool_ex -> bool_value . LOR bool_value
    (49) bool_ex -> bool_value . LAND bool_value

    EQ              shift and go to state 78
    NE              shift and go to state 72
    LE              shift and go to state 71
    GE              shift and go to state 75
    LT              shift and go to state 73
    GT              shift and go to state 76
    LOR             shift and go to state 74
    LAND            shift and go to state 77


state 34

    (82) value -> array_get .

    RPAREN          reduce using rule 82 (value -> array_get .)
    PLUS            reduce using rule 82 (value -> array_get .)
    MINUS           reduce using rule 82 (value -> array_get .)
    TIMES           reduce using rule 82 (value -> array_get .)
    DIVIDE          reduce using rule 82 (value -> array_get .)
    MOD             reduce using rule 82 (value -> array_get .)
    LSHIFT          reduce using rule 82 (value -> array_get .)
    RSHIFT          reduce using rule 82 (value -> array_get .)
    OR              reduce using rule 82 (value -> array_get .)
    AND             reduce using rule 82 (value -> array_get .)
    XOR             reduce using rule 82 (value -> array_get .)
    SEMI            reduce using rule 82 (value -> array_get .)
    EQ              reduce using rule 82 (value -> array_get .)
    NE              reduce using rule 82 (value -> array_get .)
    LE              reduce using rule 82 (value -> array_get .)
    GE              reduce using rule 82 (value -> array_get .)
    LT              reduce using rule 82 (value -> array_get .)
    GT              reduce using rule 82 (value -> array_get .)
    LOR             reduce using rule 82 (value -> array_get .)
    LAND            reduce using rule 82 (value -> array_get .)
    COMMA           reduce using rule 82 (value -> array_get .)
    RBRACKET        reduce using rule 82 (value -> array_get .)


state 35

    (79) value -> bool .

    RPAREN          reduce using rule 79 (value -> bool .)
    PLUS            reduce using rule 79 (value -> bool .)
    MINUS           reduce using rule 79 (value -> bool .)
    TIMES           reduce using rule 79 (value -> bool .)
    DIVIDE          reduce using rule 79 (value -> bool .)
    MOD             reduce using rule 79 (value -> bool .)
    LSHIFT          reduce using rule 79 (value -> bool .)
    RSHIFT          reduce using rule 79 (value -> bool .)
    OR              reduce using rule 79 (value -> bool .)
    AND             reduce using rule 79 (value -> bool .)
    XOR             reduce using rule 79 (value -> bool .)
    SEMI            reduce using rule 79 (value -> bool .)
    EQ              reduce using rule 79 (value -> bool .)
    NE              reduce using rule 79 (value -> bool .)
    LE              reduce using rule 79 (value -> bool .)
    GE              reduce using rule 79 (value -> bool .)
    LT              reduce using rule 79 (value -> bool .)
    GT              reduce using rule 79 (value -> bool .)
    LOR             reduce using rule 79 (value -> bool .)
    LAND            reduce using rule 79 (value -> bool .)
    COMMA           reduce using rule 79 (value -> bool .)
    RBRACKET        reduce using rule 79 (value -> bool .)


state 36

    (75) value -> var .

    RPAREN          reduce using rule 75 (value -> var .)
    PLUS            reduce using rule 75 (value -> var .)
    MINUS           reduce using rule 75 (value -> var .)
    TIMES           reduce using rule 75 (value -> var .)
    DIVIDE          reduce using rule 75 (value -> var .)
    MOD             reduce using rule 75 (value -> var .)
    LSHIFT          reduce using rule 75 (value -> var .)
    RSHIFT          reduce using rule 75 (value -> var .)
    OR              reduce using rule 75 (value -> var .)
    AND             reduce using rule 75 (value -> var .)
    XOR             reduce using rule 75 (value -> var .)
    SEMI            reduce using rule 75 (value -> var .)
    EQ              reduce using rule 75 (value -> var .)
    NE              reduce using rule 75 (value -> var .)
    LE              reduce using rule 75 (value -> var .)
    GE              reduce using rule 75 (value -> var .)
    LT              reduce using rule 75 (value -> var .)
    GT              reduce using rule 75 (value -> var .)
    LOR             reduce using rule 75 (value -> var .)
    LAND            reduce using rule 75 (value -> var .)
    COMMA           reduce using rule 75 (value -> var .)
    RBRACKET        reduce using rule 75 (value -> var .)


state 37

    (86) string -> STRING .

    PLUS            reduce using rule 86 (string -> STRING .)
    MINUS           reduce using rule 86 (string -> STRING .)
    TIMES           reduce using rule 86 (string -> STRING .)
    DIVIDE          reduce using rule 86 (string -> STRING .)
    MOD             reduce using rule 86 (string -> STRING .)
    LSHIFT          reduce using rule 86 (string -> STRING .)
    RSHIFT          reduce using rule 86 (string -> STRING .)
    OR              reduce using rule 86 (string -> STRING .)
    AND             reduce using rule 86 (string -> STRING .)
    XOR             reduce using rule 86 (string -> STRING .)
    SEMI            reduce using rule 86 (string -> STRING .)
    EQ              reduce using rule 86 (string -> STRING .)
    NE              reduce using rule 86 (string -> STRING .)
    LE              reduce using rule 86 (string -> STRING .)
    GE              reduce using rule 86 (string -> STRING .)
    LT              reduce using rule 86 (string -> STRING .)
    GT              reduce using rule 86 (string -> STRING .)
    LOR             reduce using rule 86 (string -> STRING .)
    LAND            reduce using rule 86 (string -> STRING .)
    RPAREN          reduce using rule 86 (string -> STRING .)
    COMMA           reduce using rule 86 (string -> STRING .)
    RBRACKET        reduce using rule 86 (string -> STRING .)


state 38

    (78) value -> string .

    RPAREN          reduce using rule 78 (value -> string .)
    PLUS            reduce using rule 78 (value -> string .)
    MINUS           reduce using rule 78 (value -> string .)
    TIMES           reduce using rule 78 (value -> string .)
    DIVIDE          reduce using rule 78 (value -> string .)
    MOD             reduce using rule 78 (value -> string .)
    LSHIFT          reduce using rule 78 (value -> string .)
    RSHIFT          reduce using rule 78 (value -> string .)
    OR              reduce using rule 78 (value -> string .)
    AND             reduce using rule 78 (value -> string .)
    XOR             reduce using rule 78 (value -> string .)
    SEMI            reduce using rule 78 (value -> string .)
    EQ              reduce using rule 78 (value -> string .)
    NE              reduce using rule 78 (value -> string .)
    LE              reduce using rule 78 (value -> string .)
    GE              reduce using rule 78 (value -> string .)
    LT              reduce using rule 78 (value -> string .)
    GT              reduce using rule 78 (value -> string .)
    LOR             reduce using rule 78 (value -> string .)
    LAND            reduce using rule 78 (value -> string .)
    COMMA           reduce using rule 78 (value -> string .)
    RBRACKET        reduce using rule 78 (value -> string .)


state 39

    (51) bool_ex -> LPAREN . bool_ex RPAREN
    (74) op_ex -> LPAREN . op_ex RPAREN
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 79
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 80
    float                          shift and go to state 27
    bool_value                     shift and go to state 33
    value                          shift and go to state 81
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 40

    (95) var -> ID .
    (5) funcall -> ID . LPAREN funcall_params RPAREN
    (93) array_get -> ID . LBRACKET INT RBRACKET
    (94) tree_get -> ID . LBRACKET string RBRACKET

    PLUS            reduce using rule 95 (var -> ID .)
    MINUS           reduce using rule 95 (var -> ID .)
    TIMES           reduce using rule 95 (var -> ID .)
    DIVIDE          reduce using rule 95 (var -> ID .)
    MOD             reduce using rule 95 (var -> ID .)
    LSHIFT          reduce using rule 95 (var -> ID .)
    RSHIFT          reduce using rule 95 (var -> ID .)
    OR              reduce using rule 95 (var -> ID .)
    AND             reduce using rule 95 (var -> ID .)
    XOR             reduce using rule 95 (var -> ID .)
    RPAREN          reduce using rule 95 (var -> ID .)
    EQ              reduce using rule 95 (var -> ID .)
    NE              reduce using rule 95 (var -> ID .)
    LE              reduce using rule 95 (var -> ID .)
    GE              reduce using rule 95 (var -> ID .)
    LT              reduce using rule 95 (var -> ID .)
    GT              reduce using rule 95 (var -> ID .)
    LOR             reduce using rule 95 (var -> ID .)
    LAND            reduce using rule 95 (var -> ID .)
    SEMI            reduce using rule 95 (var -> ID .)
    COMMA           reduce using rule 95 (var -> ID .)
    RBRACKET        reduce using rule 95 (var -> ID .)
    LPAREN          shift and go to state 63
    LBRACKET        shift and go to state 82


state 41

    (80) value -> funcall .

    RPAREN          reduce using rule 80 (value -> funcall .)
    PLUS            reduce using rule 80 (value -> funcall .)
    MINUS           reduce using rule 80 (value -> funcall .)
    TIMES           reduce using rule 80 (value -> funcall .)
    DIVIDE          reduce using rule 80 (value -> funcall .)
    MOD             reduce using rule 80 (value -> funcall .)
    LSHIFT          reduce using rule 80 (value -> funcall .)
    RSHIFT          reduce using rule 80 (value -> funcall .)
    OR              reduce using rule 80 (value -> funcall .)
    AND             reduce using rule 80 (value -> funcall .)
    XOR             reduce using rule 80 (value -> funcall .)
    SEMI            reduce using rule 80 (value -> funcall .)
    EQ              reduce using rule 80 (value -> funcall .)
    NE              reduce using rule 80 (value -> funcall .)
    LE              reduce using rule 80 (value -> funcall .)
    GE              reduce using rule 80 (value -> funcall .)
    LT              reduce using rule 80 (value -> funcall .)
    GT              reduce using rule 80 (value -> funcall .)
    LOR             reduce using rule 80 (value -> funcall .)
    LAND            reduce using rule 80 (value -> funcall .)
    COMMA           reduce using rule 80 (value -> funcall .)
    RBRACKET        reduce using rule 80 (value -> funcall .)


state 42

    (89) bool -> FALSE .

    PLUS            reduce using rule 89 (bool -> FALSE .)
    MINUS           reduce using rule 89 (bool -> FALSE .)
    TIMES           reduce using rule 89 (bool -> FALSE .)
    DIVIDE          reduce using rule 89 (bool -> FALSE .)
    MOD             reduce using rule 89 (bool -> FALSE .)
    LSHIFT          reduce using rule 89 (bool -> FALSE .)
    RSHIFT          reduce using rule 89 (bool -> FALSE .)
    OR              reduce using rule 89 (bool -> FALSE .)
    AND             reduce using rule 89 (bool -> FALSE .)
    XOR             reduce using rule 89 (bool -> FALSE .)
    SEMI            reduce using rule 89 (bool -> FALSE .)
    RPAREN          reduce using rule 89 (bool -> FALSE .)
    COMMA           reduce using rule 89 (bool -> FALSE .)
    EQ              reduce using rule 89 (bool -> FALSE .)
    NE              reduce using rule 89 (bool -> FALSE .)
    LE              reduce using rule 89 (bool -> FALSE .)
    GE              reduce using rule 89 (bool -> FALSE .)
    LT              reduce using rule 89 (bool -> FALSE .)
    GT              reduce using rule 89 (bool -> FALSE .)
    LOR             reduce using rule 89 (bool -> FALSE .)
    LAND            reduce using rule 89 (bool -> FALSE .)
    RBRACKET        reduce using rule 89 (bool -> FALSE .)


state 43

    (84) int -> INT .

    PLUS            reduce using rule 84 (int -> INT .)
    MINUS           reduce using rule 84 (int -> INT .)
    TIMES           reduce using rule 84 (int -> INT .)
    DIVIDE          reduce using rule 84 (int -> INT .)
    MOD             reduce using rule 84 (int -> INT .)
    LSHIFT          reduce using rule 84 (int -> INT .)
    RSHIFT          reduce using rule 84 (int -> INT .)
    OR              reduce using rule 84 (int -> INT .)
    AND             reduce using rule 84 (int -> INT .)
    XOR             reduce using rule 84 (int -> INT .)
    EQ              reduce using rule 84 (int -> INT .)
    NE              reduce using rule 84 (int -> INT .)
    LE              reduce using rule 84 (int -> INT .)
    GE              reduce using rule 84 (int -> INT .)
    LT              reduce using rule 84 (int -> INT .)
    GT              reduce using rule 84 (int -> INT .)
    LOR             reduce using rule 84 (int -> INT .)
    LAND            reduce using rule 84 (int -> INT .)
    SEMI            reduce using rule 84 (int -> INT .)
    RPAREN          reduce using rule 84 (int -> INT .)
    COMMA           reduce using rule 84 (int -> INT .)
    RBRACKET        reduce using rule 84 (int -> INT .)


state 44

    (85) float -> FLOAT .

    RBRACKET        reduce using rule 85 (float -> FLOAT .)
    COMMA           reduce using rule 85 (float -> FLOAT .)
    PLUS            reduce using rule 85 (float -> FLOAT .)
    MINUS           reduce using rule 85 (float -> FLOAT .)
    TIMES           reduce using rule 85 (float -> FLOAT .)
    DIVIDE          reduce using rule 85 (float -> FLOAT .)
    MOD             reduce using rule 85 (float -> FLOAT .)
    LSHIFT          reduce using rule 85 (float -> FLOAT .)
    RSHIFT          reduce using rule 85 (float -> FLOAT .)
    OR              reduce using rule 85 (float -> FLOAT .)
    AND             reduce using rule 85 (float -> FLOAT .)
    XOR             reduce using rule 85 (float -> FLOAT .)
    SEMI            reduce using rule 85 (float -> FLOAT .)
    EQ              reduce using rule 85 (float -> FLOAT .)
    NE              reduce using rule 85 (float -> FLOAT .)
    LE              reduce using rule 85 (float -> FLOAT .)
    GE              reduce using rule 85 (float -> FLOAT .)
    LT              reduce using rule 85 (float -> FLOAT .)
    GT              reduce using rule 85 (float -> FLOAT .)
    LOR             reduce using rule 85 (float -> FLOAT .)
    LAND            reduce using rule 85 (float -> FLOAT .)
    RPAREN          reduce using rule 85 (float -> FLOAT .)


state 45

    (81) value -> list .

    RPAREN          reduce using rule 81 (value -> list .)
    PLUS            reduce using rule 81 (value -> list .)
    MINUS           reduce using rule 81 (value -> list .)
    TIMES           reduce using rule 81 (value -> list .)
    DIVIDE          reduce using rule 81 (value -> list .)
    MOD             reduce using rule 81 (value -> list .)
    LSHIFT          reduce using rule 81 (value -> list .)
    RSHIFT          reduce using rule 81 (value -> list .)
    OR              reduce using rule 81 (value -> list .)
    AND             reduce using rule 81 (value -> list .)
    XOR             reduce using rule 81 (value -> list .)
    SEMI            reduce using rule 81 (value -> list .)
    EQ              reduce using rule 81 (value -> list .)
    NE              reduce using rule 81 (value -> list .)
    LE              reduce using rule 81 (value -> list .)
    GE              reduce using rule 81 (value -> list .)
    LT              reduce using rule 81 (value -> list .)
    GT              reduce using rule 81 (value -> list .)
    LOR             reduce using rule 81 (value -> list .)
    LAND            reduce using rule 81 (value -> list .)
    COMMA           reduce using rule 81 (value -> list .)
    RBRACKET        reduce using rule 81 (value -> list .)


state 46

    (39) expression -> value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex
    (52) bool_value -> value .

    SEMI            reduce using rule 39 (expression -> value .)
    RPAREN          reduce using rule 39 (expression -> value .)
    COMMA           reduce using rule 39 (expression -> value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90
    EQ              reduce using rule 52 (bool_value -> value .)
    NE              reduce using rule 52 (bool_value -> value .)
    LE              reduce using rule 52 (bool_value -> value .)
    GE              reduce using rule 52 (bool_value -> value .)
    LT              reduce using rule 52 (bool_value -> value .)
    GT              reduce using rule 52 (bool_value -> value .)
    LOR             reduce using rule 52 (bool_value -> value .)
    LAND            reduce using rule 52 (bool_value -> value .)


state 47

    (90) list -> LBRACKET . array RBRACKET
    (91) array -> . value
    (92) array -> . array COMMA value
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 94
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    array                          shift and go to state 93
    tree_get                       shift and go to state 29

state 48

    (33) return -> RETURN expression .

    SEMI            reduce using rule 33 (return -> RETURN expression .)


state 49

    (21) ex -> readd SEMI .

    RBRACE          reduce using rule 21 (ex -> readd SEMI .)
    RETURN          reduce using rule 21 (ex -> readd SEMI .)
    WRITE           reduce using rule 21 (ex -> readd SEMI .)
    READD           reduce using rule 21 (ex -> readd SEMI .)
    ID              reduce using rule 21 (ex -> readd SEMI .)
    LT              reduce using rule 21 (ex -> readd SEMI .)
    NOP             reduce using rule 21 (ex -> readd SEMI .)
    IF              reduce using rule 21 (ex -> readd SEMI .)
    FOR             reduce using rule 21 (ex -> readd SEMI .)
    $end            reduce using rule 21 (ex -> readd SEMI .)


state 50

    (22) ex -> funcall SEMI .

    RBRACE          reduce using rule 22 (ex -> funcall SEMI .)
    RETURN          reduce using rule 22 (ex -> funcall SEMI .)
    WRITE           reduce using rule 22 (ex -> funcall SEMI .)
    READD           reduce using rule 22 (ex -> funcall SEMI .)
    ID              reduce using rule 22 (ex -> funcall SEMI .)
    LT              reduce using rule 22 (ex -> funcall SEMI .)
    NOP             reduce using rule 22 (ex -> funcall SEMI .)
    IF              reduce using rule 22 (ex -> funcall SEMI .)
    FOR             reduce using rule 22 (ex -> funcall SEMI .)
    $end            reduce using rule 22 (ex -> funcall SEMI .)


state 51

    (9) function -> DEF ID . LPAREN fun_params RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 95


state 52

    (4) functions -> functions function .

    DEF             reduce using rule 4 (functions -> functions function .)
    $end            reduce using rule 4 (functions -> functions function .)


state 53

    (37) readd_esc -> LT ID . string GT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING

    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31

    string                         shift and go to state 96

state 54

    (36) readd_esc -> LT string . GT

    GT              shift and go to state 97


state 55

    (20) ex -> write SEMI .

    RBRACE          reduce using rule 20 (ex -> write SEMI .)
    RETURN          reduce using rule 20 (ex -> write SEMI .)
    WRITE           reduce using rule 20 (ex -> write SEMI .)
    READD           reduce using rule 20 (ex -> write SEMI .)
    ID              reduce using rule 20 (ex -> write SEMI .)
    LT              reduce using rule 20 (ex -> write SEMI .)
    NOP             reduce using rule 20 (ex -> write SEMI .)
    IF              reduce using rule 20 (ex -> write SEMI .)
    FOR             reduce using rule 20 (ex -> write SEMI .)
    $end            reduce using rule 20 (ex -> write SEMI .)


state 56

    (38) assign -> var EQUALS . expression
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 98
    tree_get                       shift and go to state 29

state 57

    (23) ex -> readd_esc SEMI .

    RBRACE          reduce using rule 23 (ex -> readd_esc SEMI .)
    RETURN          reduce using rule 23 (ex -> readd_esc SEMI .)
    WRITE           reduce using rule 23 (ex -> readd_esc SEMI .)
    READD           reduce using rule 23 (ex -> readd_esc SEMI .)
    ID              reduce using rule 23 (ex -> readd_esc SEMI .)
    LT              reduce using rule 23 (ex -> readd_esc SEMI .)
    NOP             reduce using rule 23 (ex -> readd_esc SEMI .)
    IF              reduce using rule 23 (ex -> readd_esc SEMI .)
    FOR             reduce using rule 23 (ex -> readd_esc SEMI .)
    $end            reduce using rule 23 (ex -> readd_esc SEMI .)


state 58

    (17) body -> body ex .

    RETURN          reduce using rule 17 (body -> body ex .)
    WRITE           reduce using rule 17 (body -> body ex .)
    READD           reduce using rule 17 (body -> body ex .)
    ID              reduce using rule 17 (body -> body ex .)
    LT              reduce using rule 17 (body -> body ex .)
    NOP             reduce using rule 17 (body -> body ex .)
    IF              reduce using rule 17 (body -> body ex .)
    FOR             reduce using rule 17 (body -> body ex .)
    $end            reduce using rule 17 (body -> body ex .)
    RBRACE          reduce using rule 17 (body -> body ex .)


state 59

    (19) ex -> return SEMI .

    RBRACE          reduce using rule 19 (ex -> return SEMI .)
    RETURN          reduce using rule 19 (ex -> return SEMI .)
    WRITE           reduce using rule 19 (ex -> return SEMI .)
    READD           reduce using rule 19 (ex -> return SEMI .)
    ID              reduce using rule 19 (ex -> return SEMI .)
    LT              reduce using rule 19 (ex -> return SEMI .)
    NOP             reduce using rule 19 (ex -> return SEMI .)
    IF              reduce using rule 19 (ex -> return SEMI .)
    FOR             reduce using rule 19 (ex -> return SEMI .)
    $end            reduce using rule 19 (ex -> return SEMI .)


state 60

    (32) foreach -> FOR LPAREN . var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    ID              shift and go to state 100

    var                            shift and go to state 99

state 61

    (34) write -> WRITE expression .

    SEMI            reduce using rule 34 (write -> WRITE expression .)


state 62

    (24) ex -> nop SEMI .

    RBRACE          reduce using rule 24 (ex -> nop SEMI .)
    RETURN          reduce using rule 24 (ex -> nop SEMI .)
    WRITE           reduce using rule 24 (ex -> nop SEMI .)
    READD           reduce using rule 24 (ex -> nop SEMI .)
    ID              reduce using rule 24 (ex -> nop SEMI .)
    LT              reduce using rule 24 (ex -> nop SEMI .)
    NOP             reduce using rule 24 (ex -> nop SEMI .)
    IF              reduce using rule 24 (ex -> nop SEMI .)
    FOR             reduce using rule 24 (ex -> nop SEMI .)
    $end            reduce using rule 24 (ex -> nop SEMI .)


state 63

    (5) funcall -> ID LPAREN . funcall_params RPAREN
    (6) funcall_params -> . empty
    (7) funcall_params -> . expression
    (8) funcall_params -> . funcall_params COMMA expression
    (96) empty -> .
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    RPAREN          reduce using rule 96 (empty -> .)
    COMMA           reduce using rule 96 (empty -> .)
    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    funcall_params                 shift and go to state 102
    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 103
    empty                          shift and go to state 101
    tree_get                       shift and go to state 29

state 64

    (29) if -> IF LPAREN . expression RPAREN LBRACE body RBRACE
    (30) if -> IF LPAREN . expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> IF LPAREN . expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    tree_get                       shift and go to state 29
    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 104

state 65

    (35) readd -> READD expression .

    SEMI            reduce using rule 35 (readd -> READD expression .)


state 66

    (18) ex -> assign SEMI .

    RBRACE          reduce using rule 18 (ex -> assign SEMI .)
    RETURN          reduce using rule 18 (ex -> assign SEMI .)
    WRITE           reduce using rule 18 (ex -> assign SEMI .)
    READD           reduce using rule 18 (ex -> assign SEMI .)
    ID              reduce using rule 18 (ex -> assign SEMI .)
    LT              reduce using rule 18 (ex -> assign SEMI .)
    NOP             reduce using rule 18 (ex -> assign SEMI .)
    IF              reduce using rule 18 (ex -> assign SEMI .)
    FOR             reduce using rule 18 (ex -> assign SEMI .)
    $end            reduce using rule 18 (ex -> assign SEMI .)


state 67

    (53) bool_value -> op_ex .

    SEMI            reduce using rule 53 (bool_value -> op_ex .)
    RPAREN          reduce using rule 53 (bool_value -> op_ex .)
    COMMA           reduce using rule 53 (bool_value -> op_ex .)


state 68

    (50) bool_ex -> LNOT bool_value .

    SEMI            reduce using rule 50 (bool_ex -> LNOT bool_value .)
    RPAREN          reduce using rule 50 (bool_ex -> LNOT bool_value .)
    COMMA           reduce using rule 50 (bool_ex -> LNOT bool_value .)


state 69

    (74) op_ex -> LPAREN . op_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 105
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 106
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 70

    (52) bool_value -> value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 52 (bool_value -> value .)
    RPAREN          reduce using rule 52 (bool_value -> value .)
    COMMA           reduce using rule 52 (bool_value -> value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 71

    (44) bool_ex -> bool_value LE . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 107
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 72

    (43) bool_ex -> bool_value NE . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 108
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 73

    (46) bool_ex -> bool_value LT . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 109
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 74

    (48) bool_ex -> bool_value LOR . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 110
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 75

    (45) bool_ex -> bool_value GE . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 111
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 76

    (47) bool_ex -> bool_value GT . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 112
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 77

    (49) bool_ex -> bool_value LAND . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 113
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 78

    (42) bool_ex -> bool_value EQ . bool_value
    (52) bool_value -> . value
    (53) bool_value -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    list                           shift and go to state 45
    op_ex                          shift and go to state 67
    float                          shift and go to state 27
    bool_value                     shift and go to state 114
    value                          shift and go to state 70
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 79

    (51) bool_ex -> LPAREN bool_ex . RPAREN

    RPAREN          shift and go to state 115


state 80

    (74) op_ex -> LPAREN op_ex . RPAREN
    (53) bool_value -> op_ex .

    RPAREN          shift and go to state 116
    EQ              reduce using rule 53 (bool_value -> op_ex .)
    NE              reduce using rule 53 (bool_value -> op_ex .)
    LE              reduce using rule 53 (bool_value -> op_ex .)
    GE              reduce using rule 53 (bool_value -> op_ex .)
    LT              reduce using rule 53 (bool_value -> op_ex .)
    GT              reduce using rule 53 (bool_value -> op_ex .)
    LOR             reduce using rule 53 (bool_value -> op_ex .)
    LAND            reduce using rule 53 (bool_value -> op_ex .)


state 81

    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex
    (52) bool_value -> value .

    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90
    EQ              reduce using rule 52 (bool_value -> value .)
    NE              reduce using rule 52 (bool_value -> value .)
    LE              reduce using rule 52 (bool_value -> value .)
    GE              reduce using rule 52 (bool_value -> value .)
    LT              reduce using rule 52 (bool_value -> value .)
    GT              reduce using rule 52 (bool_value -> value .)
    LOR             reduce using rule 52 (bool_value -> value .)
    LAND            reduce using rule 52 (bool_value -> value .)


state 82

    (93) array_get -> ID LBRACKET . INT RBRACKET
    (94) tree_get -> ID LBRACKET . string RBRACKET
    (86) string -> . STRING
    (87) string -> . MULTI_STRING

    INT             shift and go to state 117
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31

    string                         shift and go to state 118

state 83

    (62) op_ex -> value AND . value
    (72) op_ex -> value AND . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 119
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 120
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 84

    (61) op_ex -> value OR . value
    (71) op_ex -> value OR . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 121
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 122
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 85

    (60) op_ex -> value RSHIFT . value
    (70) op_ex -> value RSHIFT . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 123
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 124
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 86

    (57) op_ex -> value DIVIDE . value
    (67) op_ex -> value DIVIDE . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 125
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 126
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 87

    (56) op_ex -> value TIMES . value
    (66) op_ex -> value TIMES . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 127
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 128
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 88

    (54) op_ex -> value PLUS . value
    (64) op_ex -> value PLUS . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 129
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 130
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 89

    (59) op_ex -> value LSHIFT . value
    (69) op_ex -> value LSHIFT . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 131
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 132
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 90

    (63) op_ex -> value XOR . value
    (73) op_ex -> value XOR . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 133
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 134
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 91

    (55) op_ex -> value MINUS . value
    (65) op_ex -> value MINUS . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 135
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 136
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 92

    (58) op_ex -> value MOD . value
    (68) op_ex -> value MOD . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    LPAREN          shift and go to state 69
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    op_ex                          shift and go to state 137
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 138
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 93

    (90) list -> LBRACKET array . RBRACKET
    (92) array -> array . COMMA value

    RBRACKET        shift and go to state 140
    COMMA           shift and go to state 139


state 94

    (91) array -> value .

    RBRACKET        reduce using rule 91 (array -> value .)
    COMMA           reduce using rule 91 (array -> value .)


state 95

    (9) function -> DEF ID LPAREN . fun_params RPAREN LBRACE body RBRACE
    (10) fun_params -> . empty
    (11) fun_params -> . ID
    (12) fun_params -> . fun_pointer
    (13) fun_params -> . fun_params COMMA fun_pointer
    (14) fun_params -> . fun_params COMMA ID
    (96) empty -> .
    (15) fun_pointer -> . ID LPAREN RPAREN

    ID              shift and go to state 144
    RPAREN          reduce using rule 96 (empty -> .)
    COMMA           reduce using rule 96 (empty -> .)

    fun_params                     shift and go to state 142
    fun_pointer                    shift and go to state 141
    empty                          shift and go to state 143

state 96

    (37) readd_esc -> LT ID string . GT

    GT              shift and go to state 145


state 97

    (36) readd_esc -> LT string GT .

    SEMI            reduce using rule 36 (readd_esc -> LT string GT .)
    RBRACE          reduce using rule 36 (readd_esc -> LT string GT .)
    RETURN          reduce using rule 36 (readd_esc -> LT string GT .)
    WRITE           reduce using rule 36 (readd_esc -> LT string GT .)
    READD           reduce using rule 36 (readd_esc -> LT string GT .)
    ID              reduce using rule 36 (readd_esc -> LT string GT .)
    LT              reduce using rule 36 (readd_esc -> LT string GT .)
    NOP             reduce using rule 36 (readd_esc -> LT string GT .)
    IF              reduce using rule 36 (readd_esc -> LT string GT .)
    FOR             reduce using rule 36 (readd_esc -> LT string GT .)
    $end            reduce using rule 36 (readd_esc -> LT string GT .)


state 98

    (38) assign -> var EQUALS expression .

    SEMI            reduce using rule 38 (assign -> var EQUALS expression .)


state 99

    (32) foreach -> FOR LPAREN var . COLON value RPAREN LBRACE body RBRACE

    COLON           shift and go to state 146


state 100

    (95) var -> ID .

    COLON           reduce using rule 95 (var -> ID .)


state 101

    (6) funcall_params -> empty .

    RPAREN          reduce using rule 6 (funcall_params -> empty .)
    COMMA           reduce using rule 6 (funcall_params -> empty .)


state 102

    (5) funcall -> ID LPAREN funcall_params . RPAREN
    (8) funcall_params -> funcall_params . COMMA expression

    RPAREN          shift and go to state 147
    COMMA           shift and go to state 148


state 103

    (7) funcall_params -> expression .

    RPAREN          reduce using rule 7 (funcall_params -> expression .)
    COMMA           reduce using rule 7 (funcall_params -> expression .)


state 104

    (29) if -> IF LPAREN expression . RPAREN LBRACE body RBRACE
    (30) if -> IF LPAREN expression . RPAREN LBRACE body RBRACE ELSE if
    (31) if -> IF LPAREN expression . RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE

    RPAREN          shift and go to state 149


state 105

    (74) op_ex -> LPAREN op_ex . RPAREN

    RPAREN          shift and go to state 116


state 106

    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 107

    (44) bool_ex -> bool_value LE bool_value .

    SEMI            reduce using rule 44 (bool_ex -> bool_value LE bool_value .)
    RPAREN          reduce using rule 44 (bool_ex -> bool_value LE bool_value .)
    COMMA           reduce using rule 44 (bool_ex -> bool_value LE bool_value .)


state 108

    (43) bool_ex -> bool_value NE bool_value .

    SEMI            reduce using rule 43 (bool_ex -> bool_value NE bool_value .)
    RPAREN          reduce using rule 43 (bool_ex -> bool_value NE bool_value .)
    COMMA           reduce using rule 43 (bool_ex -> bool_value NE bool_value .)


state 109

    (46) bool_ex -> bool_value LT bool_value .

    SEMI            reduce using rule 46 (bool_ex -> bool_value LT bool_value .)
    RPAREN          reduce using rule 46 (bool_ex -> bool_value LT bool_value .)
    COMMA           reduce using rule 46 (bool_ex -> bool_value LT bool_value .)


state 110

    (48) bool_ex -> bool_value LOR bool_value .

    SEMI            reduce using rule 48 (bool_ex -> bool_value LOR bool_value .)
    RPAREN          reduce using rule 48 (bool_ex -> bool_value LOR bool_value .)
    COMMA           reduce using rule 48 (bool_ex -> bool_value LOR bool_value .)


state 111

    (45) bool_ex -> bool_value GE bool_value .

    SEMI            reduce using rule 45 (bool_ex -> bool_value GE bool_value .)
    RPAREN          reduce using rule 45 (bool_ex -> bool_value GE bool_value .)
    COMMA           reduce using rule 45 (bool_ex -> bool_value GE bool_value .)


state 112

    (47) bool_ex -> bool_value GT bool_value .

    SEMI            reduce using rule 47 (bool_ex -> bool_value GT bool_value .)
    RPAREN          reduce using rule 47 (bool_ex -> bool_value GT bool_value .)
    COMMA           reduce using rule 47 (bool_ex -> bool_value GT bool_value .)


state 113

    (49) bool_ex -> bool_value LAND bool_value .

    SEMI            reduce using rule 49 (bool_ex -> bool_value LAND bool_value .)
    RPAREN          reduce using rule 49 (bool_ex -> bool_value LAND bool_value .)
    COMMA           reduce using rule 49 (bool_ex -> bool_value LAND bool_value .)


state 114

    (42) bool_ex -> bool_value EQ bool_value .

    SEMI            reduce using rule 42 (bool_ex -> bool_value EQ bool_value .)
    RPAREN          reduce using rule 42 (bool_ex -> bool_value EQ bool_value .)
    COMMA           reduce using rule 42 (bool_ex -> bool_value EQ bool_value .)


state 115

    (51) bool_ex -> LPAREN bool_ex RPAREN .

    SEMI            reduce using rule 51 (bool_ex -> LPAREN bool_ex RPAREN .)
    RPAREN          reduce using rule 51 (bool_ex -> LPAREN bool_ex RPAREN .)
    COMMA           reduce using rule 51 (bool_ex -> LPAREN bool_ex RPAREN .)


state 116

    (74) op_ex -> LPAREN op_ex RPAREN .

    SEMI            reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    EQ              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    NE              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    LE              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    GE              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    LT              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    GT              reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    LOR             reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    LAND            reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    RPAREN          reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)
    COMMA           reduce using rule 74 (op_ex -> LPAREN op_ex RPAREN .)


state 117

    (93) array_get -> ID LBRACKET INT . RBRACKET

    RBRACKET        shift and go to state 150


state 118

    (94) tree_get -> ID LBRACKET string . RBRACKET

    RBRACKET        shift and go to state 151


state 119

    (72) op_ex -> value AND op_ex .

    SEMI            reduce using rule 72 (op_ex -> value AND op_ex .)
    EQ              reduce using rule 72 (op_ex -> value AND op_ex .)
    NE              reduce using rule 72 (op_ex -> value AND op_ex .)
    LE              reduce using rule 72 (op_ex -> value AND op_ex .)
    GE              reduce using rule 72 (op_ex -> value AND op_ex .)
    LT              reduce using rule 72 (op_ex -> value AND op_ex .)
    GT              reduce using rule 72 (op_ex -> value AND op_ex .)
    LOR             reduce using rule 72 (op_ex -> value AND op_ex .)
    LAND            reduce using rule 72 (op_ex -> value AND op_ex .)
    RPAREN          reduce using rule 72 (op_ex -> value AND op_ex .)
    COMMA           reduce using rule 72 (op_ex -> value AND op_ex .)


state 120

    (62) op_ex -> value AND value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 62 (op_ex -> value AND value .)
    EQ              reduce using rule 62 (op_ex -> value AND value .)
    NE              reduce using rule 62 (op_ex -> value AND value .)
    LE              reduce using rule 62 (op_ex -> value AND value .)
    GE              reduce using rule 62 (op_ex -> value AND value .)
    LT              reduce using rule 62 (op_ex -> value AND value .)
    GT              reduce using rule 62 (op_ex -> value AND value .)
    LOR             reduce using rule 62 (op_ex -> value AND value .)
    LAND            reduce using rule 62 (op_ex -> value AND value .)
    RPAREN          reduce using rule 62 (op_ex -> value AND value .)
    COMMA           reduce using rule 62 (op_ex -> value AND value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 121

    (71) op_ex -> value OR op_ex .

    SEMI            reduce using rule 71 (op_ex -> value OR op_ex .)
    EQ              reduce using rule 71 (op_ex -> value OR op_ex .)
    NE              reduce using rule 71 (op_ex -> value OR op_ex .)
    LE              reduce using rule 71 (op_ex -> value OR op_ex .)
    GE              reduce using rule 71 (op_ex -> value OR op_ex .)
    LT              reduce using rule 71 (op_ex -> value OR op_ex .)
    GT              reduce using rule 71 (op_ex -> value OR op_ex .)
    LOR             reduce using rule 71 (op_ex -> value OR op_ex .)
    LAND            reduce using rule 71 (op_ex -> value OR op_ex .)
    RPAREN          reduce using rule 71 (op_ex -> value OR op_ex .)
    COMMA           reduce using rule 71 (op_ex -> value OR op_ex .)


state 122

    (61) op_ex -> value OR value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 61 (op_ex -> value OR value .)
    EQ              reduce using rule 61 (op_ex -> value OR value .)
    NE              reduce using rule 61 (op_ex -> value OR value .)
    LE              reduce using rule 61 (op_ex -> value OR value .)
    GE              reduce using rule 61 (op_ex -> value OR value .)
    LT              reduce using rule 61 (op_ex -> value OR value .)
    GT              reduce using rule 61 (op_ex -> value OR value .)
    LOR             reduce using rule 61 (op_ex -> value OR value .)
    LAND            reduce using rule 61 (op_ex -> value OR value .)
    RPAREN          reduce using rule 61 (op_ex -> value OR value .)
    COMMA           reduce using rule 61 (op_ex -> value OR value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 123

    (70) op_ex -> value RSHIFT op_ex .

    SEMI            reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    EQ              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    NE              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    LE              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    GE              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    LT              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    GT              reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    LOR             reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    LAND            reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    RPAREN          reduce using rule 70 (op_ex -> value RSHIFT op_ex .)
    COMMA           reduce using rule 70 (op_ex -> value RSHIFT op_ex .)


state 124

    (60) op_ex -> value RSHIFT value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 60 (op_ex -> value RSHIFT value .)
    EQ              reduce using rule 60 (op_ex -> value RSHIFT value .)
    NE              reduce using rule 60 (op_ex -> value RSHIFT value .)
    LE              reduce using rule 60 (op_ex -> value RSHIFT value .)
    GE              reduce using rule 60 (op_ex -> value RSHIFT value .)
    LT              reduce using rule 60 (op_ex -> value RSHIFT value .)
    GT              reduce using rule 60 (op_ex -> value RSHIFT value .)
    LOR             reduce using rule 60 (op_ex -> value RSHIFT value .)
    LAND            reduce using rule 60 (op_ex -> value RSHIFT value .)
    RPAREN          reduce using rule 60 (op_ex -> value RSHIFT value .)
    COMMA           reduce using rule 60 (op_ex -> value RSHIFT value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 125

    (67) op_ex -> value DIVIDE op_ex .

    SEMI            reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    EQ              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    NE              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    LE              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    GE              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    LT              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    GT              reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    LOR             reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    LAND            reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    RPAREN          reduce using rule 67 (op_ex -> value DIVIDE op_ex .)
    COMMA           reduce using rule 67 (op_ex -> value DIVIDE op_ex .)


state 126

    (57) op_ex -> value DIVIDE value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 57 (op_ex -> value DIVIDE value .)
    EQ              reduce using rule 57 (op_ex -> value DIVIDE value .)
    NE              reduce using rule 57 (op_ex -> value DIVIDE value .)
    LE              reduce using rule 57 (op_ex -> value DIVIDE value .)
    GE              reduce using rule 57 (op_ex -> value DIVIDE value .)
    LT              reduce using rule 57 (op_ex -> value DIVIDE value .)
    GT              reduce using rule 57 (op_ex -> value DIVIDE value .)
    LOR             reduce using rule 57 (op_ex -> value DIVIDE value .)
    LAND            reduce using rule 57 (op_ex -> value DIVIDE value .)
    RPAREN          reduce using rule 57 (op_ex -> value DIVIDE value .)
    COMMA           reduce using rule 57 (op_ex -> value DIVIDE value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 127

    (66) op_ex -> value TIMES op_ex .

    SEMI            reduce using rule 66 (op_ex -> value TIMES op_ex .)
    EQ              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    NE              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    LE              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    GE              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    LT              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    GT              reduce using rule 66 (op_ex -> value TIMES op_ex .)
    LOR             reduce using rule 66 (op_ex -> value TIMES op_ex .)
    LAND            reduce using rule 66 (op_ex -> value TIMES op_ex .)
    RPAREN          reduce using rule 66 (op_ex -> value TIMES op_ex .)
    COMMA           reduce using rule 66 (op_ex -> value TIMES op_ex .)


state 128

    (56) op_ex -> value TIMES value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 56 (op_ex -> value TIMES value .)
    EQ              reduce using rule 56 (op_ex -> value TIMES value .)
    NE              reduce using rule 56 (op_ex -> value TIMES value .)
    LE              reduce using rule 56 (op_ex -> value TIMES value .)
    GE              reduce using rule 56 (op_ex -> value TIMES value .)
    LT              reduce using rule 56 (op_ex -> value TIMES value .)
    GT              reduce using rule 56 (op_ex -> value TIMES value .)
    LOR             reduce using rule 56 (op_ex -> value TIMES value .)
    LAND            reduce using rule 56 (op_ex -> value TIMES value .)
    RPAREN          reduce using rule 56 (op_ex -> value TIMES value .)
    COMMA           reduce using rule 56 (op_ex -> value TIMES value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 129

    (64) op_ex -> value PLUS op_ex .

    SEMI            reduce using rule 64 (op_ex -> value PLUS op_ex .)
    EQ              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    NE              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    LE              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    GE              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    LT              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    GT              reduce using rule 64 (op_ex -> value PLUS op_ex .)
    LOR             reduce using rule 64 (op_ex -> value PLUS op_ex .)
    LAND            reduce using rule 64 (op_ex -> value PLUS op_ex .)
    RPAREN          reduce using rule 64 (op_ex -> value PLUS op_ex .)
    COMMA           reduce using rule 64 (op_ex -> value PLUS op_ex .)


state 130

    (54) op_ex -> value PLUS value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 54 (op_ex -> value PLUS value .)
    EQ              reduce using rule 54 (op_ex -> value PLUS value .)
    NE              reduce using rule 54 (op_ex -> value PLUS value .)
    LE              reduce using rule 54 (op_ex -> value PLUS value .)
    GE              reduce using rule 54 (op_ex -> value PLUS value .)
    LT              reduce using rule 54 (op_ex -> value PLUS value .)
    GT              reduce using rule 54 (op_ex -> value PLUS value .)
    LOR             reduce using rule 54 (op_ex -> value PLUS value .)
    LAND            reduce using rule 54 (op_ex -> value PLUS value .)
    RPAREN          reduce using rule 54 (op_ex -> value PLUS value .)
    COMMA           reduce using rule 54 (op_ex -> value PLUS value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 131

    (69) op_ex -> value LSHIFT op_ex .

    SEMI            reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    EQ              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    NE              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    LE              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    GE              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    LT              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    GT              reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    LOR             reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    LAND            reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    RPAREN          reduce using rule 69 (op_ex -> value LSHIFT op_ex .)
    COMMA           reduce using rule 69 (op_ex -> value LSHIFT op_ex .)


state 132

    (59) op_ex -> value LSHIFT value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 59 (op_ex -> value LSHIFT value .)
    EQ              reduce using rule 59 (op_ex -> value LSHIFT value .)
    NE              reduce using rule 59 (op_ex -> value LSHIFT value .)
    LE              reduce using rule 59 (op_ex -> value LSHIFT value .)
    GE              reduce using rule 59 (op_ex -> value LSHIFT value .)
    LT              reduce using rule 59 (op_ex -> value LSHIFT value .)
    GT              reduce using rule 59 (op_ex -> value LSHIFT value .)
    LOR             reduce using rule 59 (op_ex -> value LSHIFT value .)
    LAND            reduce using rule 59 (op_ex -> value LSHIFT value .)
    RPAREN          reduce using rule 59 (op_ex -> value LSHIFT value .)
    COMMA           reduce using rule 59 (op_ex -> value LSHIFT value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 133

    (73) op_ex -> value XOR op_ex .

    SEMI            reduce using rule 73 (op_ex -> value XOR op_ex .)
    EQ              reduce using rule 73 (op_ex -> value XOR op_ex .)
    NE              reduce using rule 73 (op_ex -> value XOR op_ex .)
    LE              reduce using rule 73 (op_ex -> value XOR op_ex .)
    GE              reduce using rule 73 (op_ex -> value XOR op_ex .)
    LT              reduce using rule 73 (op_ex -> value XOR op_ex .)
    GT              reduce using rule 73 (op_ex -> value XOR op_ex .)
    LOR             reduce using rule 73 (op_ex -> value XOR op_ex .)
    LAND            reduce using rule 73 (op_ex -> value XOR op_ex .)
    RPAREN          reduce using rule 73 (op_ex -> value XOR op_ex .)
    COMMA           reduce using rule 73 (op_ex -> value XOR op_ex .)


state 134

    (63) op_ex -> value XOR value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 63 (op_ex -> value XOR value .)
    EQ              reduce using rule 63 (op_ex -> value XOR value .)
    NE              reduce using rule 63 (op_ex -> value XOR value .)
    LE              reduce using rule 63 (op_ex -> value XOR value .)
    GE              reduce using rule 63 (op_ex -> value XOR value .)
    LT              reduce using rule 63 (op_ex -> value XOR value .)
    GT              reduce using rule 63 (op_ex -> value XOR value .)
    LOR             reduce using rule 63 (op_ex -> value XOR value .)
    LAND            reduce using rule 63 (op_ex -> value XOR value .)
    RPAREN          reduce using rule 63 (op_ex -> value XOR value .)
    COMMA           reduce using rule 63 (op_ex -> value XOR value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 135

    (65) op_ex -> value MINUS op_ex .

    SEMI            reduce using rule 65 (op_ex -> value MINUS op_ex .)
    EQ              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    NE              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    LE              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    GE              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    LT              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    GT              reduce using rule 65 (op_ex -> value MINUS op_ex .)
    LOR             reduce using rule 65 (op_ex -> value MINUS op_ex .)
    LAND            reduce using rule 65 (op_ex -> value MINUS op_ex .)
    RPAREN          reduce using rule 65 (op_ex -> value MINUS op_ex .)
    COMMA           reduce using rule 65 (op_ex -> value MINUS op_ex .)


state 136

    (55) op_ex -> value MINUS value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 55 (op_ex -> value MINUS value .)
    EQ              reduce using rule 55 (op_ex -> value MINUS value .)
    NE              reduce using rule 55 (op_ex -> value MINUS value .)
    LE              reduce using rule 55 (op_ex -> value MINUS value .)
    GE              reduce using rule 55 (op_ex -> value MINUS value .)
    LT              reduce using rule 55 (op_ex -> value MINUS value .)
    GT              reduce using rule 55 (op_ex -> value MINUS value .)
    LOR             reduce using rule 55 (op_ex -> value MINUS value .)
    LAND            reduce using rule 55 (op_ex -> value MINUS value .)
    RPAREN          reduce using rule 55 (op_ex -> value MINUS value .)
    COMMA           reduce using rule 55 (op_ex -> value MINUS value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 137

    (68) op_ex -> value MOD op_ex .

    SEMI            reduce using rule 68 (op_ex -> value MOD op_ex .)
    EQ              reduce using rule 68 (op_ex -> value MOD op_ex .)
    NE              reduce using rule 68 (op_ex -> value MOD op_ex .)
    LE              reduce using rule 68 (op_ex -> value MOD op_ex .)
    GE              reduce using rule 68 (op_ex -> value MOD op_ex .)
    LT              reduce using rule 68 (op_ex -> value MOD op_ex .)
    GT              reduce using rule 68 (op_ex -> value MOD op_ex .)
    LOR             reduce using rule 68 (op_ex -> value MOD op_ex .)
    LAND            reduce using rule 68 (op_ex -> value MOD op_ex .)
    RPAREN          reduce using rule 68 (op_ex -> value MOD op_ex .)
    COMMA           reduce using rule 68 (op_ex -> value MOD op_ex .)


state 138

    (58) op_ex -> value MOD value .
    (54) op_ex -> value . PLUS value
    (55) op_ex -> value . MINUS value
    (56) op_ex -> value . TIMES value
    (57) op_ex -> value . DIVIDE value
    (58) op_ex -> value . MOD value
    (59) op_ex -> value . LSHIFT value
    (60) op_ex -> value . RSHIFT value
    (61) op_ex -> value . OR value
    (62) op_ex -> value . AND value
    (63) op_ex -> value . XOR value
    (64) op_ex -> value . PLUS op_ex
    (65) op_ex -> value . MINUS op_ex
    (66) op_ex -> value . TIMES op_ex
    (67) op_ex -> value . DIVIDE op_ex
    (68) op_ex -> value . MOD op_ex
    (69) op_ex -> value . LSHIFT op_ex
    (70) op_ex -> value . RSHIFT op_ex
    (71) op_ex -> value . OR op_ex
    (72) op_ex -> value . AND op_ex
    (73) op_ex -> value . XOR op_ex

    SEMI            reduce using rule 58 (op_ex -> value MOD value .)
    EQ              reduce using rule 58 (op_ex -> value MOD value .)
    NE              reduce using rule 58 (op_ex -> value MOD value .)
    LE              reduce using rule 58 (op_ex -> value MOD value .)
    GE              reduce using rule 58 (op_ex -> value MOD value .)
    LT              reduce using rule 58 (op_ex -> value MOD value .)
    GT              reduce using rule 58 (op_ex -> value MOD value .)
    LOR             reduce using rule 58 (op_ex -> value MOD value .)
    LAND            reduce using rule 58 (op_ex -> value MOD value .)
    RPAREN          reduce using rule 58 (op_ex -> value MOD value .)
    COMMA           reduce using rule 58 (op_ex -> value MOD value .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 91
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 86
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 89
    RSHIFT          shift and go to state 85
    OR              shift and go to state 84
    AND             shift and go to state 83
    XOR             shift and go to state 90


state 139

    (92) array -> array COMMA . value
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 152
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 140

    (90) list -> LBRACKET array RBRACKET .

    PLUS            reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    MINUS           reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    TIMES           reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    DIVIDE          reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    MOD             reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    LSHIFT          reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    RSHIFT          reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    OR              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    AND             reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    XOR             reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    SEMI            reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    EQ              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    NE              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    LE              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    GE              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    LT              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    GT              reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    LOR             reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    LAND            reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    RPAREN          reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    COMMA           reduce using rule 90 (list -> LBRACKET array RBRACKET .)
    RBRACKET        reduce using rule 90 (list -> LBRACKET array RBRACKET .)


state 141

    (12) fun_params -> fun_pointer .

    RPAREN          reduce using rule 12 (fun_params -> fun_pointer .)
    COMMA           reduce using rule 12 (fun_params -> fun_pointer .)


state 142

    (9) function -> DEF ID LPAREN fun_params . RPAREN LBRACE body RBRACE
    (13) fun_params -> fun_params . COMMA fun_pointer
    (14) fun_params -> fun_params . COMMA ID

    RPAREN          shift and go to state 153
    COMMA           shift and go to state 154


state 143

    (10) fun_params -> empty .

    RPAREN          reduce using rule 10 (fun_params -> empty .)
    COMMA           reduce using rule 10 (fun_params -> empty .)


state 144

    (11) fun_params -> ID .
    (15) fun_pointer -> ID . LPAREN RPAREN

    RPAREN          reduce using rule 11 (fun_params -> ID .)
    COMMA           reduce using rule 11 (fun_params -> ID .)
    LPAREN          shift and go to state 155


state 145

    (37) readd_esc -> LT ID string GT .

    SEMI            reduce using rule 37 (readd_esc -> LT ID string GT .)
    RBRACE          reduce using rule 37 (readd_esc -> LT ID string GT .)
    RETURN          reduce using rule 37 (readd_esc -> LT ID string GT .)
    WRITE           reduce using rule 37 (readd_esc -> LT ID string GT .)
    READD           reduce using rule 37 (readd_esc -> LT ID string GT .)
    ID              reduce using rule 37 (readd_esc -> LT ID string GT .)
    LT              reduce using rule 37 (readd_esc -> LT ID string GT .)
    NOP             reduce using rule 37 (readd_esc -> LT ID string GT .)
    IF              reduce using rule 37 (readd_esc -> LT ID string GT .)
    FOR             reduce using rule 37 (readd_esc -> LT ID string GT .)
    $end            reduce using rule 37 (readd_esc -> LT ID string GT .)


state 146

    (32) foreach -> FOR LPAREN var COLON . value RPAREN LBRACE body RBRACE
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET

    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    int                            shift and go to state 26
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 156
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    tree_get                       shift and go to state 29

state 147

    (5) funcall -> ID LPAREN funcall_params RPAREN .

    SEMI            reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    PLUS            reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    MINUS           reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    TIMES           reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    DIVIDE          reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    MOD             reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    LSHIFT          reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    RSHIFT          reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    OR              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    AND             reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    XOR             reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    EQ              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    NE              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    LE              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    GE              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    LT              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    GT              reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    LOR             reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    LAND            reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    RPAREN          reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    COMMA           reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)
    RBRACKET        reduce using rule 5 (funcall -> ID LPAREN funcall_params RPAREN .)


state 148

    (8) funcall_params -> funcall_params COMMA . expression
    (39) expression -> . value
    (40) expression -> . bool_ex
    (41) expression -> . op_ex
    (75) value -> . var
    (76) value -> . int
    (77) value -> . float
    (78) value -> . string
    (79) value -> . bool
    (80) value -> . funcall
    (81) value -> . list
    (82) value -> . array_get
    (83) value -> . tree_get
    (42) bool_ex -> . bool_value EQ bool_value
    (43) bool_ex -> . bool_value NE bool_value
    (44) bool_ex -> . bool_value LE bool_value
    (45) bool_ex -> . bool_value GE bool_value
    (46) bool_ex -> . bool_value LT bool_value
    (47) bool_ex -> . bool_value GT bool_value
    (48) bool_ex -> . bool_value LOR bool_value
    (49) bool_ex -> . bool_value LAND bool_value
    (50) bool_ex -> . LNOT bool_value
    (51) bool_ex -> . LPAREN bool_ex RPAREN
    (54) op_ex -> . value PLUS value
    (55) op_ex -> . value MINUS value
    (56) op_ex -> . value TIMES value
    (57) op_ex -> . value DIVIDE value
    (58) op_ex -> . value MOD value
    (59) op_ex -> . value LSHIFT value
    (60) op_ex -> . value RSHIFT value
    (61) op_ex -> . value OR value
    (62) op_ex -> . value AND value
    (63) op_ex -> . value XOR value
    (64) op_ex -> . value PLUS op_ex
    (65) op_ex -> . value MINUS op_ex
    (66) op_ex -> . value TIMES op_ex
    (67) op_ex -> . value DIVIDE op_ex
    (68) op_ex -> . value MOD op_ex
    (69) op_ex -> . value LSHIFT op_ex
    (70) op_ex -> . value RSHIFT op_ex
    (71) op_ex -> . value OR op_ex
    (72) op_ex -> . value AND op_ex
    (73) op_ex -> . value XOR op_ex
    (74) op_ex -> . LPAREN op_ex RPAREN
    (95) var -> . ID
    (84) int -> . INT
    (85) float -> . FLOAT
    (86) string -> . STRING
    (87) string -> . MULTI_STRING
    (88) bool -> . TRUE
    (89) bool -> . FALSE
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (90) list -> . LBRACKET array RBRACKET
    (93) array_get -> . ID LBRACKET INT RBRACKET
    (94) tree_get -> . ID LBRACKET string RBRACKET
    (52) bool_value -> . value
    (53) bool_value -> . op_ex

    LNOT            shift and go to state 25
    LPAREN          shift and go to state 39
    ID              shift and go to state 40
    INT             shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 37
    MULTI_STRING    shift and go to state 31
    TRUE            shift and go to state 28
    FALSE           shift and go to state 42
    LBRACKET        shift and go to state 47

    string                         shift and go to state 38
    bool_ex                        shift and go to state 30
    int                            shift and go to state 26
    bool_value                     shift and go to state 33
    op_ex                          shift and go to state 32
    float                          shift and go to state 27
    list                           shift and go to state 45
    value                          shift and go to state 46
    array_get                      shift and go to state 34
    funcall                        shift and go to state 41
    bool                           shift and go to state 35
    var                            shift and go to state 36
    expression                     shift and go to state 157
    tree_get                       shift and go to state 29

state 149

    (29) if -> IF LPAREN expression RPAREN . LBRACE body RBRACE
    (30) if -> IF LPAREN expression RPAREN . LBRACE body RBRACE ELSE if
    (31) if -> IF LPAREN expression RPAREN . LBRACE body RBRACE ELSE LBRACE body RBRACE

    LBRACE          shift and go to state 158


state 150

    (93) array_get -> ID LBRACKET INT RBRACKET .

    PLUS            reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    MINUS           reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    TIMES           reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    DIVIDE          reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    MOD             reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    LSHIFT          reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    RSHIFT          reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    OR              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    AND             reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    XOR             reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    SEMI            reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    RPAREN          reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    COMMA           reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    EQ              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    NE              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    LE              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    GE              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    LT              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    GT              reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    LOR             reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    LAND            reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)
    RBRACKET        reduce using rule 93 (array_get -> ID LBRACKET INT RBRACKET .)


state 151

    (94) tree_get -> ID LBRACKET string RBRACKET .

    PLUS            reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    MINUS           reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    TIMES           reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    DIVIDE          reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    MOD             reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    LSHIFT          reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    RSHIFT          reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    OR              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    AND             reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    XOR             reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    SEMI            reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    EQ              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    NE              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    LE              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    GE              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    LT              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    GT              reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    LOR             reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    LAND            reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    RPAREN          reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    COMMA           reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)
    RBRACKET        reduce using rule 94 (tree_get -> ID LBRACKET string RBRACKET .)


state 152

    (92) array -> array COMMA value .

    RBRACKET        reduce using rule 92 (array -> array COMMA value .)
    COMMA           reduce using rule 92 (array -> array COMMA value .)


state 153

    (9) function -> DEF ID LPAREN fun_params RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 159


state 154

    (13) fun_params -> fun_params COMMA . fun_pointer
    (14) fun_params -> fun_params COMMA . ID
    (15) fun_pointer -> . ID LPAREN RPAREN

    ID              shift and go to state 161

    fun_pointer                    shift and go to state 160

state 155

    (15) fun_pointer -> ID LPAREN . RPAREN

    RPAREN          shift and go to state 162


state 156

    (32) foreach -> FOR LPAREN var COLON value . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 163


state 157

    (8) funcall_params -> funcall_params COMMA expression .

    RPAREN          reduce using rule 8 (funcall_params -> funcall_params COMMA expression .)
    COMMA           reduce using rule 8 (funcall_params -> funcall_params COMMA expression .)


state 158

    (29) if -> IF LPAREN expression RPAREN LBRACE . body RBRACE
    (30) if -> IF LPAREN expression RPAREN LBRACE . body RBRACE ELSE if
    (31) if -> IF LPAREN expression RPAREN LBRACE . body RBRACE ELSE LBRACE body RBRACE
    (16) body -> . ex
    (17) body -> . body ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    body                           shift and go to state 164
    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    nop                            shift and go to state 19
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 5
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 159

    (9) function -> DEF ID LPAREN fun_params RPAREN LBRACE . body RBRACE
    (16) body -> . ex
    (17) body -> . body ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    body                           shift and go to state 165
    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 5
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 160

    (13) fun_params -> fun_params COMMA fun_pointer .

    RPAREN          reduce using rule 13 (fun_params -> fun_params COMMA fun_pointer .)
    COMMA           reduce using rule 13 (fun_params -> fun_params COMMA fun_pointer .)


state 161

    (14) fun_params -> fun_params COMMA ID .
    (15) fun_pointer -> ID . LPAREN RPAREN

    RPAREN          reduce using rule 14 (fun_params -> fun_params COMMA ID .)
    COMMA           reduce using rule 14 (fun_params -> fun_params COMMA ID .)
    LPAREN          shift and go to state 155


state 162

    (15) fun_pointer -> ID LPAREN RPAREN .

    RPAREN          reduce using rule 15 (fun_pointer -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 15 (fun_pointer -> ID LPAREN RPAREN .)


state 163

    (32) foreach -> FOR LPAREN var COLON value RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 166


state 164

    (29) if -> IF LPAREN expression RPAREN LBRACE body . RBRACE
    (30) if -> IF LPAREN expression RPAREN LBRACE body . RBRACE ELSE if
    (31) if -> IF LPAREN expression RPAREN LBRACE body . RBRACE ELSE LBRACE body RBRACE
    (17) body -> body . ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RBRACE          shift and go to state 167
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    nop                            shift and go to state 19
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 58
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 165

    (9) function -> DEF ID LPAREN fun_params RPAREN LBRACE body . RBRACE
    (17) body -> body . ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RBRACE          shift and go to state 168
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 58
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 166

    (32) foreach -> FOR LPAREN var COLON value RPAREN LBRACE . body RBRACE
    (16) body -> . ex
    (17) body -> . body ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    body                           shift and go to state 169
    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 5
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 167

    (29) if -> IF LPAREN expression RPAREN LBRACE body RBRACE .
    (30) if -> IF LPAREN expression RPAREN LBRACE body RBRACE . ELSE if
    (31) if -> IF LPAREN expression RPAREN LBRACE body RBRACE . ELSE LBRACE body RBRACE

    RBRACE          reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    WRITE           reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    READD           reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    LT              reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    NOP             reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 29 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE .)
    ELSE            shift and go to state 170


state 168

    (9) function -> DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE .

    DEF             reduce using rule 9 (function -> DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 9 (function -> DEF ID LPAREN fun_params RPAREN LBRACE body RBRACE .)


state 169

    (32) foreach -> FOR LPAREN var COLON value RPAREN LBRACE body . RBRACE
    (17) body -> body . ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RBRACE          shift and go to state 171
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 58
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    nop                            shift and go to state 19
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 170

    (30) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE . if
    (31) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE . LBRACE body RBRACE
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE

    LBRACE          shift and go to state 172
    IF              shift and go to state 21

    if                             shift and go to state 173

state 171

    (32) foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .

    RETURN          reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    WRITE           reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    READD           reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    LT              reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    NOP             reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 32 (foreach -> FOR LPAREN var COLON value RPAREN LBRACE body RBRACE .)


state 172

    (31) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE . body RBRACE
    (16) body -> . ex
    (17) body -> . body ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    body                           shift and go to state 174
    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    nop                            shift and go to state 19
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 5
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 173

    (30) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .

    RBRACE          reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    RETURN          reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    WRITE           reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    READD           reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    ID              reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    LT              reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    NOP             reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    IF              reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    FOR             reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)
    $end            reduce using rule 30 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if .)


state 174

    (31) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body . RBRACE
    (17) body -> body . ex
    (18) ex -> . assign SEMI
    (19) ex -> . return SEMI
    (20) ex -> . write SEMI
    (21) ex -> . readd SEMI
    (22) ex -> . funcall SEMI
    (23) ex -> . readd_esc SEMI
    (24) ex -> . nop SEMI
    (25) ex -> . if
    (26) ex -> . foreach
    (27) ex -> . readd_esc
    (38) assign -> . var EQUALS expression
    (33) return -> . RETURN expression
    (34) write -> . WRITE expression
    (35) readd -> . READD expression
    (5) funcall -> . ID LPAREN funcall_params RPAREN
    (36) readd_esc -> . LT string GT
    (37) readd_esc -> . LT ID string GT
    (28) nop -> . NOP
    (29) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE
    (30) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE if
    (31) if -> . IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE
    (32) foreach -> . FOR LPAREN var COLON value RPAREN LBRACE body RBRACE
    (95) var -> . ID

    RBRACE          shift and go to state 175
    RETURN          shift and go to state 2
    WRITE           shift and go to state 18
    READD           shift and go to state 22
    ID              shift and go to state 20
    LT              shift and go to state 10
    NOP             shift and go to state 23
    IF              shift and go to state 21
    FOR             shift and go to state 17

    funcall                        shift and go to state 4
    return                         shift and go to state 16
    readd                          shift and go to state 3
    nop                            shift and go to state 19
    foreach                        shift and go to state 12
    write                          shift and go to state 11
    ex                             shift and go to state 58
    var                            shift and go to state 13
    readd_esc                      shift and go to state 14
    assign                         shift and go to state 24
    if                             shift and go to state 8

state 175

    (31) if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .

    RBRACE          reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    RETURN          reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    WRITE           reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    READD           reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    ID              reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    LT              reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    NOP             reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    IF              reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    FOR             reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)
    $end            reduce using rule 31 (if -> IF LPAREN expression RPAREN LBRACE body RBRACE ELSE LBRACE body RBRACE .)

